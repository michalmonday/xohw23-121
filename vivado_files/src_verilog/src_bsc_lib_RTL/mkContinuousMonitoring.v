//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
//
// Ports:
// Name                         I/O  size props
// pc                             O    64 const
// instr                          O    32 const
// pc_valid                       O     1 const
// evt_MEM_CAP_LOAD               O    64 const
// evt_MEM_CAP_STORE              O    64 const
// evt_MEM_CAP_LOAD_TAG_SET       O    64 const
// evt_MEM_CAP_STORE_TAG_SET      O    64 const
// tgc_evt_WRITE                  O    64 const
// tgc_evt_WRITE_MISS             O    64 const
// tgc_evt_READ                   O    64 const
// tgc_evt_READ_MISS              O    64 const
// tgc_evt_EVICT                  O    64 const
// tgc_evt_SET_TAG_WRITE          O    64 const
// tgc_evt_SET_TAG_READ           O    64 const
// axi_mem_aw_canPut              O     1 const
// RDY_axi_mem_aw_put             O     1 const
// axi_mem_w_canPut               O     1 const
// RDY_axi_mem_w_put              O     1 const
// axi_mem_b_canPeek              O     1 const
// axi_mem_b_peek                 O     8 const
// RDY_axi_mem_b_peek             O     1 const
// RDY_axi_mem_b_drop             O     1 const
// axi_mem_ar_canPut              O     1 const
// RDY_axi_mem_ar_put             O     1 const
// axi_mem_r_canPeek              O     1 const
// axi_mem_r_peek                 O   521 const
// RDY_axi_mem_r_peek             O     1 const
// RDY_axi_mem_r_drop             O     1 const
// CLK                            I     1 unused
// RST_N                          I     1 unused
// axi_mem_aw_put_val             I    99 unused
// axi_mem_w_put_val              I   577 unused
// axi_mem_ar_put_val             I    99 unused
// EN_axi_mem_aw_put              I     1 unused
// EN_axi_mem_w_put               I     1 unused
// EN_axi_mem_b_drop              I     1 unused
// EN_axi_mem_ar_put              I     1 unused
// EN_axi_mem_r_drop              I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkContinuousMonitoring(CLK,
			      RST_N,

			      pc,

			      instr,

			      pc_valid,

			      evt_MEM_CAP_LOAD,

			      evt_MEM_CAP_STORE,

			      evt_MEM_CAP_LOAD_TAG_SET,

			      evt_MEM_CAP_STORE_TAG_SET,

			      tgc_evt_WRITE,

			      tgc_evt_WRITE_MISS,

			      tgc_evt_READ,

			      tgc_evt_READ_MISS,

			      tgc_evt_EVICT,

			      tgc_evt_SET_TAG_WRITE,

			      tgc_evt_SET_TAG_READ,

			      axi_mem_aw_canPut,

			      axi_mem_aw_put_val,
			      EN_axi_mem_aw_put,
			      RDY_axi_mem_aw_put,

			      axi_mem_w_canPut,

			      axi_mem_w_put_val,
			      EN_axi_mem_w_put,
			      RDY_axi_mem_w_put,

			      axi_mem_b_canPeek,

			      axi_mem_b_peek,
			      RDY_axi_mem_b_peek,

			      EN_axi_mem_b_drop,
			      RDY_axi_mem_b_drop,

			      axi_mem_ar_canPut,

			      axi_mem_ar_put_val,
			      EN_axi_mem_ar_put,
			      RDY_axi_mem_ar_put,

			      axi_mem_r_canPeek,

			      axi_mem_r_peek,
			      RDY_axi_mem_r_peek,

			      EN_axi_mem_r_drop,
			      RDY_axi_mem_r_drop);
  input  CLK;
  input  RST_N;

  // value method pc
  output [63 : 0] pc;

  // value method instr
  output [31 : 0] instr;

  // value method pc_valid
  output pc_valid;

  // value method evt_MEM_CAP_LOAD
  output [63 : 0] evt_MEM_CAP_LOAD;

  // value method evt_MEM_CAP_STORE
  output [63 : 0] evt_MEM_CAP_STORE;

  // value method evt_MEM_CAP_LOAD_TAG_SET
  output [63 : 0] evt_MEM_CAP_LOAD_TAG_SET;

  // value method evt_MEM_CAP_STORE_TAG_SET
  output [63 : 0] evt_MEM_CAP_STORE_TAG_SET;

  // value method tgc_evt_WRITE
  output [63 : 0] tgc_evt_WRITE;

  // value method tgc_evt_WRITE_MISS
  output [63 : 0] tgc_evt_WRITE_MISS;

  // value method tgc_evt_READ
  output [63 : 0] tgc_evt_READ;

  // value method tgc_evt_READ_MISS
  output [63 : 0] tgc_evt_READ_MISS;

  // value method tgc_evt_EVICT
  output [63 : 0] tgc_evt_EVICT;

  // value method tgc_evt_SET_TAG_WRITE
  output [63 : 0] tgc_evt_SET_TAG_WRITE;

  // value method tgc_evt_SET_TAG_READ
  output [63 : 0] tgc_evt_SET_TAG_READ;

  // value method axi_mem_aw_canPut
  output axi_mem_aw_canPut;

  // action method axi_mem_aw_put
  input  [98 : 0] axi_mem_aw_put_val;
  input  EN_axi_mem_aw_put;
  output RDY_axi_mem_aw_put;

  // value method axi_mem_w_canPut
  output axi_mem_w_canPut;

  // action method axi_mem_w_put
  input  [576 : 0] axi_mem_w_put_val;
  input  EN_axi_mem_w_put;
  output RDY_axi_mem_w_put;

  // value method axi_mem_b_canPeek
  output axi_mem_b_canPeek;

  // value method axi_mem_b_peek
  output [7 : 0] axi_mem_b_peek;
  output RDY_axi_mem_b_peek;

  // action method axi_mem_b_drop
  input  EN_axi_mem_b_drop;
  output RDY_axi_mem_b_drop;

  // value method axi_mem_ar_canPut
  output axi_mem_ar_canPut;

  // action method axi_mem_ar_put
  input  [98 : 0] axi_mem_ar_put_val;
  input  EN_axi_mem_ar_put;
  output RDY_axi_mem_ar_put;

  // value method axi_mem_r_canPeek
  output axi_mem_r_canPeek;

  // value method axi_mem_r_peek
  output [520 : 0] axi_mem_r_peek;
  output RDY_axi_mem_r_peek;

  // action method axi_mem_r_drop
  input  EN_axi_mem_r_drop;
  output RDY_axi_mem_r_drop;

  // signals for module outputs
  wire [520 : 0] axi_mem_r_peek;
  wire [63 : 0] evt_MEM_CAP_LOAD,
		evt_MEM_CAP_LOAD_TAG_SET,
		evt_MEM_CAP_STORE,
		evt_MEM_CAP_STORE_TAG_SET,
		pc,
		tgc_evt_EVICT,
		tgc_evt_READ,
		tgc_evt_READ_MISS,
		tgc_evt_SET_TAG_READ,
		tgc_evt_SET_TAG_WRITE,
		tgc_evt_WRITE,
		tgc_evt_WRITE_MISS;
  wire [31 : 0] instr;
  wire [7 : 0] axi_mem_b_peek;
  wire RDY_axi_mem_ar_put,
       RDY_axi_mem_aw_put,
       RDY_axi_mem_b_drop,
       RDY_axi_mem_b_peek,
       RDY_axi_mem_r_drop,
       RDY_axi_mem_r_peek,
       RDY_axi_mem_w_put,
       axi_mem_ar_canPut,
       axi_mem_aw_canPut,
       axi_mem_b_canPeek,
       axi_mem_r_canPeek,
       axi_mem_w_canPut,
       pc_valid;

  // rule scheduling signals
  wire CAN_FIRE_axi_mem_ar_put,
       CAN_FIRE_axi_mem_aw_put,
       CAN_FIRE_axi_mem_b_drop,
       CAN_FIRE_axi_mem_r_drop,
       CAN_FIRE_axi_mem_w_put,
       WILL_FIRE_axi_mem_ar_put,
       WILL_FIRE_axi_mem_aw_put,
       WILL_FIRE_axi_mem_b_drop,
       WILL_FIRE_axi_mem_r_drop,
       WILL_FIRE_axi_mem_w_put;

  // value method pc
  assign pc = 64'hAAAAAAAAAAAAAAAA ;

  // value method instr
  assign instr = 32'hAAAAAAAA ;

  // value method pc_valid
  assign pc_valid = 1'h0 ;

  // value method evt_MEM_CAP_LOAD
  assign evt_MEM_CAP_LOAD = 64'hAAAAAAAAAAAAAAAA ;

  // value method evt_MEM_CAP_STORE
  assign evt_MEM_CAP_STORE = 64'hAAAAAAAAAAAAAAAA ;

  // value method evt_MEM_CAP_LOAD_TAG_SET
  assign evt_MEM_CAP_LOAD_TAG_SET = 64'hAAAAAAAAAAAAAAAA ;

  // value method evt_MEM_CAP_STORE_TAG_SET
  assign evt_MEM_CAP_STORE_TAG_SET = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_WRITE
  assign tgc_evt_WRITE = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_WRITE_MISS
  assign tgc_evt_WRITE_MISS = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_READ
  assign tgc_evt_READ = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_READ_MISS
  assign tgc_evt_READ_MISS = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_EVICT
  assign tgc_evt_EVICT = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_SET_TAG_WRITE
  assign tgc_evt_SET_TAG_WRITE = 64'hAAAAAAAAAAAAAAAA ;

  // value method tgc_evt_SET_TAG_READ
  assign tgc_evt_SET_TAG_READ = 64'hAAAAAAAAAAAAAAAA ;

  // value method axi_mem_aw_canPut
  assign axi_mem_aw_canPut = 1'h0 ;

  // action method axi_mem_aw_put
  assign RDY_axi_mem_aw_put = 1'd1 ;
  assign CAN_FIRE_axi_mem_aw_put = 1'd1 ;
  assign WILL_FIRE_axi_mem_aw_put = EN_axi_mem_aw_put ;

  // value method axi_mem_w_canPut
  assign axi_mem_w_canPut = 1'h0 ;

  // action method axi_mem_w_put
  assign RDY_axi_mem_w_put = 1'd1 ;
  assign CAN_FIRE_axi_mem_w_put = 1'd1 ;
  assign WILL_FIRE_axi_mem_w_put = EN_axi_mem_w_put ;

  // value method axi_mem_b_canPeek
  assign axi_mem_b_canPeek = 1'h0 ;

  // value method axi_mem_b_peek
  assign axi_mem_b_peek = 8'hAA ;
  assign RDY_axi_mem_b_peek = 1'd1 ;

  // action method axi_mem_b_drop
  assign RDY_axi_mem_b_drop = 1'd1 ;
  assign CAN_FIRE_axi_mem_b_drop = 1'd1 ;
  assign WILL_FIRE_axi_mem_b_drop = EN_axi_mem_b_drop ;

  // value method axi_mem_ar_canPut
  assign axi_mem_ar_canPut = 1'h0 ;

  // action method axi_mem_ar_put
  assign RDY_axi_mem_ar_put = 1'd1 ;
  assign CAN_FIRE_axi_mem_ar_put = 1'd1 ;
  assign WILL_FIRE_axi_mem_ar_put = EN_axi_mem_ar_put ;

  // value method axi_mem_r_canPeek
  assign axi_mem_r_canPeek = 1'h0 ;

  // value method axi_mem_r_peek
  assign axi_mem_r_peek =
	     521'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ;
  assign RDY_axi_mem_r_peek = 1'd1 ;

  // action method axi_mem_r_drop
  assign RDY_axi_mem_r_drop = 1'd1 ;
  assign CAN_FIRE_axi_mem_r_drop = 1'd1 ;
  assign WILL_FIRE_axi_mem_r_drop = EN_axi_mem_r_drop ;
endmodule  // mkContinuousMonitoring

